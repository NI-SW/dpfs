

%{
 #include "dpfsparser.hpp"
 #define YYSTYPE std::string
 // #define YY_NO_UNPUT
 #include "parser.hpp"
 static YYSTYPE idStr;
 static void yyunput (int c, char * yy_bp );

 // #define unput(c) yyunput (c, yytext_ptr);

 void pars_unput(const std::string& str) {
    unput(' ');
    for(auto it = str.rbegin(); it != str.rend(); ++it) {
        unput(*it);
    }
    unput(' ');
 }

 void dpunput(int c) {
    switch(c) {
        case PARS_ADD_TOKEN:
            pars_unput("ADD");
            break;
        case PARS_DROP_TOKEN:
            pars_unput("DROP");
            break;
        default:
            break;
    }
    return;
 }
%}

/* 
 * ID               Schema名规则
*/

ID              [a-z_A-Z][a-z_A-Z0-9]*
OBJ_NAME        [a-z_A-Z][@a-z_A-Z0-9]*
DOT             \.

%x comment
%x comment2
%x id
%%

"/*"                    BEGIN(comment); /* eat up comment */
<comment>[^*]*          
<comment>"*"+[^*/]*         
<comment>"*"+"/"        BEGIN(INITIAL);

"--"                    BEGIN(comment2);
<comment2>[^\n]*
<comment2>[\n]{1,1}     BEGIN(INITIAL);

\"              {
                        BEGIN(id);
                        idStr = "";
}
<id>[^\"]+      {
                        idStr.append(yytext);
}
<id>\"+ {
                        idStr.append(yytext, yyleng / 2);

                        if (yyleng % 2) {
                                BEGIN(INITIAL);
                                yylval = idStr.c_str();
                                idStr.clear();
                                return(PARS_ID_TOKEN);
                        }
}


[ \r\t\n]+              /* eat up whitespace */

UNIQUE {
    return(PARS_UNIQUE_TOKEN);
}

RENAME {
    return(PARS_RENAME_TOKEN);
}

ADD {
#ifdef PARSER_DEBUG
    printf("\nadd tk\n");
    printf("token: %s add\n", yytext);
#endif
    return(PARS_ADD_TOKEN);
}

ALIAS {
    return(PARS_ALIAS_TOKEN);
}

CASCADE {
    return(PARS_CASCADE_TOKEN);
}

COLUMN {
    return(PARS_COLUMN_TOKEN);
}

SYNONYM {
    return(PARS_ALIAS_TOKEN);
}

PUBLIC {
    return(PARS_PUBLIC_TOKEN);
}

TRIGGER {
    return(PARS_TRIGGER_TOKEN);
}

TYPE {
    return(PARS_TYPE_TOKEN);
}

VIEW {
    return(PARS_VIEW_TOKEN);
}

SCHEMA {
    return(PARS_SCHEMA_TOKEN);
}

AUTHORIZATION {
    return(PARS_AUTH_TOKEN);
}

ALTER {
    return(PARS_ALTER_TOKEN);
}

TABLE {
    return(PARS_TABLE_TOKEN);
}

FUNCTION {
    return(PARS_FUNCTION_TOKEN);
}

INDEX {
    return(PARS_INDEX_TOKEN);
}

CREATE {
#ifdef PARSER_DEBUG
    printf("\ncreate tk\n");
    printf("token: %s CRE\n", yytext);
#endif
    return(PARS_CREATE_TOKEN);
}

OR {
    return(PARS_OR_TOKEN);
}

REPLACE {
    return(PARS_REPLACE_TOKEN);
}

RESTRICT {
    return(PARS_RESTRICT_TOKEN);
}

IF {
    return(PARS_IF_TOKEN);
}

NOT {
    return(PARS_NOT_TOKEN);
}

EXISTS {
    return(PARS_EXISTS_TOKEN);
}

DROP {
#ifdef PARSER_DEBUG
    printf("\ndrop tk\n");
    printf("token: %s DRP\n", yytext);
#endif
    return(PARS_DROP_TOKEN);
}

SEQUENCE {
#ifdef PARSER_DEBUG
    printf("\npc tk\n");
    printf("token: %s PC\n", yytext);
#endif
    return(PARS_SEQUENCE_TOKEN);
}

PROCEDURE {
#ifdef PARSER_DEBUG
    printf("\npc tk\n");
    printf("token: %s PC\n", yytext);
#endif
    return(PARS_PROCEDURE_TOKEN);
}

{ID} {
#ifdef PARSER_DEBUG
    printf("\nnm tk\n");
    printf("tok: %s NM\n", yytext);
#endif
    yylval.assign(yytext);
    return(PARS_ID_TOKEN);
}

{OBJ_NAME} {
    yylval.assign(yytext);
    return(PARS_ID_TOKEN);
}

{DOT} {
    return(PARS_DOT_TOKEN);
}

%%
 
 
int yywrap() { 
    yy_flush_buffer(YY_CURRENT_BUFFER);
    BEGIN INITIAL;
    return 1;
}
